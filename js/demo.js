// Generated by CoffeeScript 1.6.3
(function() {
  var PEER_JS_API_KEY;

  PEER_JS_API_KEY = '2db0hg7b28iwwmi';

  navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

  angular.module("webrtcdemo", ['firebase']).config(function($compileProvider) {
    $compileProvider.imgSrcSanitizationWhitelist(/^\s*(https?|ftp|file|blob):|data:image\//);
    return $compileProvider.aHrefSanitizationWhitelist(/^\s*(https?|ftp|mailto|tel|file|blob):/);
  }).filter('bytes', function() {
    return function(b) {
      var m, u, _i, _len, _ref;
      if (isNaN(parseFloat(b)) || !isFinite(b)) {
        return '';
      }
      m = 1;
      _ref = ['bytes', 'kB', 'MB', 'GB', 'TB', 'PB'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        u = _ref[_i];
        if (b < (m * 1000)) {
          return "" + (Math.round(b / m * 10) / 10) + " " + u;
        }
        m *= 1000;
      }
    };
  }).controller("demoCtrl", function($scope, $timeout, $sce, $q, angularFire) {
    var addChatMessage, addFile, getMyVideo, handlePeerEvent, myId, ref, scrollElementToBottom, sendEventToAllPeers, setupPeerConnection;
    getMyVideo = (function() {
      var constraints, dfd;
      dfd = $q.defer();
      constraints = navigator.userAgent.match(/Firefox\/2[0-7]/) ? {
        video: true
      } : {
        video: {
          mandatory: {
            maxWidth: 320,
            maxHeight: 180
          }
        }
      };
      navigator.getUserMedia(constraints, dfd.resolve, dfd.reject);
      return dfd.promise;
    })();
    getMyVideo.then(function(stream) {
      return $scope.me.videoUrl = $sce.trustAsResourceUrl(URL.createObjectURL(stream));
    }, function() {
      return console.error('Failed to get local video stream');
    });
    myId = +(new Date);
    $scope.me = {
      firebaseRef: {
        name: "Visitor " + myId
      }
    };
    $scope.chatMessages = [];
    $scope.files = [];
    $scope.peerConnections = {};
    $scope.firebaseUsers = {};
    ref = new Firebase('https://ryanswebrtcdemo.firebaseio.com/onlineUsers');
    angularFire(ref, $scope, "firebaseUsers");
    $scope.$watch('firebaseUsers', function(newValue, oldValue) {
      var id, myRef, userId, _results;
      if (myRef = $scope.firebaseUsers[$scope.me.userId]) {
        $scope.me.firebaseRef = myRef;
      }
      for (id in $scope.peerConnections) {
        if (!newValue[id]) {
          delete $scope.peerConnections[id];
        }
      }
      _results = [];
      for (userId in newValue) {
        _results.push(setupPeerConnection(userId));
      }
      return _results;
    });
    $scope.peer = new Peer(myId, {
      key: PEER_JS_API_KEY,
      debug: 3
    });
    $scope.peer.on('open', function(id) {
      return $scope.$apply(function() {
        $scope.me.userId = id;
        return $scope.firebaseUsers[id] = $scope.me.firebaseRef;
      });
    });
    $scope.peer.on('connection', function(conn) {
      return $scope.$apply(function() {
        return setupPeerConnection(conn.peer, {
          dataConn: conn
        });
      });
    });
    $scope.peer.on('call', function(call) {
      return $scope.$apply(function() {
        return getMyVideo.then(function(myVideoStream) {
          call.answer(myVideoStream);
          return setupPeerConnection(call.peer, {
            mediaConn: call
          });
        });
      });
    });
    $scope.peer.on('close', function() {
      return $scope.$apply(function() {
        return delete $scope.firebaseUsers[$scope.peer.id];
      });
    });
    window.onunload = window.onbeforeunload = function() {
      return $scope.peer.destroy();
    };
    scrollElementToBottom = function(elementId) {
      return $timeout(function() {
        var _ref;
        return (_ref = document.getElementById(elementId)) != null ? _ref.scrollTop = 9999999999 : void 0;
      });
    };
    addChatMessage = function(authorId, message) {
      var author;
      author = authorId === $scope.peer.id ? $scope.me : $scope.peerConnections[authorId];
      $scope.chatMessages.push({
        author: author,
        message: message
      });
      return scrollElementToBottom('chat-message-holder');
    };
    addFile = function(from, data) {
      var url;
      if (data.file.constructor === ArrayBuffer) {
        data.file = new Blob([new Uint8Array(data.file)]);
      }
      url = URL.createObjectURL(data.file);
      data.url = $sce.trustAsResourceUrl(url);
      data.uploader = from === $scope.peer.id ? $scope.me : $scope.peerConnections[from];
      $scope.files.push(data);
      return scrollElementToBottom('file-uploads-holder');
    };
    $scope.postChatMessage = function() {
      addChatMessage($scope.peer.id, $scope.chatMessage);
      sendEventToAllPeers('chat_message', $scope.chatMessage);
      return $scope.chatMessage = '';
    };
    $scope.uploadFiles = function(files) {
      return $scope.$apply(function() {
        return angular.forEach(files, function(file) {
          var fileData;
          fileData = {
            file: file,
            name: file.name,
            type: file.type,
            size: file.size
          };
          sendEventToAllPeers('file_transfer', fileData);
          return addFile($scope.peer.id, fileData);
        });
      });
    };
    sendEventToAllPeers = function(type, data) {
      var id, user, _ref, _results;
      _ref = $scope.peerConnections;
      _results = [];
      for (id in _ref) {
        user = _ref[id];
        _results.push(user.dataConn.send({
          type: type,
          data: data
        }));
      }
      return _results;
    };
    handlePeerEvent = function(from, type, data) {
      switch (type) {
        case 'chat_message':
          return addChatMessage(from, data);
        case 'file_transfer':
          return addFile(from, data);
      }
    };
    return setupPeerConnection = function(userId, options) {
      var dataConn, heHasBeenOnlineLongerThanIHave, mediaConn, user, _base;
      if (options == null) {
        options = {};
      }
      if (userId === $scope.peer.id) {
        return;
      }
      dataConn = options.dataConn, mediaConn = options.mediaConn;
      user = (_base = $scope.peerConnections)[userId] || (_base[userId] = {});
      user.userId = userId;
      user.firebaseRef = $scope.firebaseUsers[userId];
      heHasBeenOnlineLongerThanIHave = userId < $scope.peer.id;
      if (!user.dataConn && (dataConn || heHasBeenOnlineLongerThanIHave)) {
        if (heHasBeenOnlineLongerThanIHave) {
          dataConn || (dataConn = $scope.peer.connect(userId));
        }
        if (dataConn) {
          if (user.DataConn) {
            console.warn('connecting 2x to user', user, dataConn);
          }
          user.dataConn = dataConn;
          user.dataConn.on('data', function(_arg) {
            var data, type;
            type = _arg.type, data = _arg.data;
            return $scope.$apply(function() {
              return handlePeerEvent(user.dataConn.peer, type, data);
            });
          });
        }
      }
      return getMyVideo.then(function(myVideoStream) {
        user.mediaConn || (user.mediaConn = mediaConn || $scope.peer.call(userId, myVideoStream));
        if (!user.mediaConn.open) {
          user.mediaConn.answer(myVideoStream);
        }
        return user.mediaConn.on('stream', function(remoteStream) {
          return $scope.$apply(function() {
            var url;
            url = URL.createObjectURL(remoteStream);
            return user.videoUrl = $sce.trustAsResourceUrl(url);
          });
        });
      });
    };
  });

}).call(this);
