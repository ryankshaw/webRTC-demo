// Generated by CoffeeScript 1.6.3
(function() {
  var API_KEY, PRESENTING_PEERS_ID, allParticipants, presentingPeer, tellEveryoneSomeoneNewIsOnline,
    __slice = [].slice;

  API_KEY = '2db0hg7b28iwwmi';

  PRESENTING_PEERS_ID = 'presenterwerwe';

  if (location.search.match('presenter')) {
    allParticipants = {};
    tellEveryoneSomeoneNewIsOnline = function() {
      var c, id, ids, _results;
      ids = Object.keys(allParticipants);
      _results = [];
      for (id in allParticipants) {
        c = allParticipants[id];
        _results.push(c.send({
          type: 'user_added',
          data: ids
        }));
      }
      return _results;
    };
    presentingPeer = new Peer(PRESENTING_PEERS_ID, {
      key: API_KEY,
      debug: 3
    });
    presentingPeer.on('connection', function(conn) {
      allParticipants[conn.peer] = conn;
      return tellEveryoneSomeoneNewIsOnline();
    });
  }

  angular.module("webrtcdemo", []).config(function($compileProvider) {
    $compileProvider.imgSrcSanitizationWhitelist(/^\s*(https?|ftp|file|blob):|data:image\//);
    return $compileProvider.aHrefSanitizationWhitelist(/^\s*(https?|ftp|mailto|tel|file|blob):/);
  }).filter('bytes', function() {
    var units;
    units = ['bytes', 'kB', 'MB', 'GB', 'TB', 'PB'];
    return function(bytes, precision) {
      var mult, quantity, unitname, _i, _len;
      if (precision == null) {
        precision = 1;
      }
      if (isNaN(parseFloat(bytes)) || !isFinite(bytes)) {
        return '';
      }
      mult = 1;
      for (_i = 0, _len = units.length; _i < _len; _i++) {
        unitname = units[_i];
        if (bytes < (mult * 1000)) {
          quantity = bytes / mult;
          quantity = Math.round(quantity * 10) / 10;
          return "" + quantity + " " + unitname;
        }
        mult *= 1000;
      }
      return bytes;
    };
  }).controller("demoCtrl", function($scope, $timeout, $sce, $q) {
    var addChatMessage, addFile, getMyVideo, handlePeerEvent, presenterConn, sendEventToAllPeers, setupPeerConnection;
    getMyVideo = (function() {
      var dfd;
      dfd = $q.defer();
      navigator.getMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
      navigator.getMedia({
        video: true,
        audio: true
      }, dfd.resolve, dfd.reject);
      return dfd.promise;
    })();
    getMyVideo.then(function(stream) {
      return $scope.me.videoUrl = $sce.trustAsResourceUrl(URL.createObjectURL(stream));
    }, console.error.bind(console, 'Failed to get local stream'));
    $scope.peerConnections = {};
    $scope.chatMessages = [];
    $scope.files = [];
    $scope.me = {};
    $scope.peer = new Peer({
      key: API_KEY,
      debug: 3
    });
    $scope.peer.on('open', function(id) {
      return $scope.$apply(function() {
        return $scope.me.userId = id;
      });
    });
    $scope.peer.on('connection', function(conn) {
      return $scope.$apply(function() {
        return setupPeerConnection(conn.peer, {
          dataConn: conn
        });
      });
    });
    $scope.peer.on('call', function(call) {
      return $scope.$apply(function() {
        return getMyVideo.then(function(myVideoStream) {
          call.answer(myVideoStream);
          return setupPeerConnection(call.peer, {
            mediaConn: call
          });
        });
      });
    });
    console.log("Connecting to the presenter so he can tell me who's online.");
    presenterConn = $scope.peer.connect(PRESENTING_PEERS_ID, {
      reliable: true
    });
    presenterConn.on('data', function(_arg) {
      var data, type;
      type = _arg.type, data = _arg.data;
      return $scope.$apply(function() {
        var user, _i, _len, _results;
        console.log.apply(console, ['presenter says these people are online'].concat(__slice.call(data)));
        _results = [];
        for (_i = 0, _len = data.length; _i < _len; _i++) {
          user = data[_i];
          _results.push(setupPeerConnection(user));
        }
        return _results;
      });
    });
    addChatMessage = function(authorId, message) {
      var author;
      author = authorId === $scope.peer.id ? $scope.me : $scope.peerConnections[authorId];
      $scope.chatMessages.push({
        author: author,
        message: message
      });
      return $timeout(function() {
        var _ref;
        return (_ref = document.getElementById('chat-message-holder')) != null ? _ref.scrollTop = 9999999999 : void 0;
      });
    };
    addFile = function(from, data) {
      var dataView, url;
      if (data.file.constructor === ArrayBuffer) {
        dataView = new Uint8Array(data.file);
        data.file = new Blob([dataView]);
      }
      url = URL.createObjectURL(data.file);
      data.url = $sce.trustAsResourceUrl(url);
      data.previewType = data.type.match('image') ? 'image' : data.type.match('video') ? 'video' : data.type.match('audio') ? 'audio' : void 0;
      data.author = from === $scope.peer.id ? $scope.me : $scope.peerConnections[from];
      $scope.files.push(data);
      return $timeout(function() {
        var _ref;
        return (_ref = document.getElementById('file-uploads-holder')) != null ? _ref.scrollTop = 9999999999 : void 0;
      });
    };
    $scope.postChatMessage = function() {
      addChatMessage($scope.peer.id, $scope.chatMessage);
      sendEventToAllPeers('chat_message', $scope.chatMessage);
      return $scope.chatMessage = '';
    };
    $scope.uploadFiles = function(files) {
      return $scope.$apply(function() {
        return angular.forEach(files, function(file) {
          var fileData;
          fileData = {
            file: file,
            name: file.name,
            type: file.type,
            size: file.size
          };
          sendEventToAllPeers('file_transfer', fileData);
          return addFile($scope.peer.id, fileData);
        });
      });
    };
    sendEventToAllPeers = function(type, data) {
      var id, user, _ref, _results;
      _ref = $scope.peerConnections;
      _results = [];
      for (id in _ref) {
        user = _ref[id];
        _results.push(user.dataConn.send({
          type: type,
          data: data
        }));
      }
      return _results;
    };
    handlePeerEvent = function(from, type, data) {
      switch (type) {
        case 'chat_message':
          return addChatMessage(from, data);
        case 'file_transfer':
          return addFile(from, data);
      }
    };
    return setupPeerConnection = function(userId, options) {
      var dataConn, mediaConn, user, _base;
      if (options == null) {
        options = {};
      }
      dataConn = options.dataConn, mediaConn = options.mediaConn;
      user = (_base = $scope.peerConnections)[userId] || (_base[userId] = {});
      user.userId = userId;
      if (!user.dataConn) {
        user.dataConn = dataConn || $scope.peer.connect(userId, {
          reliable: true
        });
        user.dataConn.on('data', function(_arg) {
          var data, type;
          type = _arg.type, data = _arg.data;
          return $scope.$apply(function() {
            return handlePeerEvent(user.dataConn.peer, type, data);
          });
        });
      }
      return getMyVideo.then(function(myVideoStream) {
        if (!user.mediaConn) {
          user.mediaConn = mediaConn || $scope.peer.call(userId, myVideoStream);
        }
        if (user.mediaConn && !user.mediaConn.open) {
          user.mediaConn.answer(myVideoStream);
        }
        return user.mediaConn.on('stream', function(remoteStream) {
          return $scope.$apply(function() {
            var url;
            url = URL.createObjectURL(remoteStream);
            return user.videoUrl = $sce.trustAsResourceUrl(url);
          });
        });
      });
    };
  });

}).call(this);
